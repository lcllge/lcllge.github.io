<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一起学习JDK1.8新特性(八)]]></title>
    <url>%2Funcategorized%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7-%E5%85%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[一起学习JDK1.8新特性(七)]]></title>
    <url>%2Funcategorized%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7-%E4%B8%83%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[一起学习JDK1.8新特性(六)]]></title>
    <url>%2Funcategorized%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7-%E5%85%AD%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[一起学习JDK1.8新特性(五)]]></title>
    <url>%2Funcategorized%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7-%E4%BA%94%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[一起学习JDK1.8新特性(四)]]></title>
    <url>%2Funcategorized%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[生活就像一盒各式各样的巧克力,你永远不知道下一块是什么味道 为了更好的学习JDK1.8的新特性,我之前给大家带来了,Lambda表达式的基本用法,以及相应的讲解,在之前的文章中有着很重要的知识点我们来梳理下: Lambda表达式通常用于函数接口的对象返回 在JDK1.8中接口可以有具体方法了(default方法) 对于接口函数(有@FunctionalInterface注解的接口)只能有一个抽象方法,其实这就是我们之前提到的java.util.function包下面的这个接口 Lmabda表达式能帮助我们简化代码,同时本质就是实现接口的过程 好了,现在让我们来学习新知识—流(stream),这个是也是jdk1.8的新特性,注意,此流非彼流,并不是IO流中的那个东西,这里的流我们可以认为是一个类似迭代器之类的东西,因为我们用到它的时候通常都是对List或者Collection操作 现在看个例子 12List&lt;Integer&gt; list1 = Arrays.asList(12, 78, 58, 36, -25, -56, 89, 0);list1.stream().sorted((a,b)-&gt;a.compareTo(b)); 这个简单的例子即是stream流的简单应用,这里实现了一个排序功能,和之前的数组排序差不多是不是,这里都是实现了Comparator接口去排序,不同的是这个方法使用到了流 好了现在,正式接触流的编程,先定义个实体类 1234567public class Person&#123; private String firstName, lastName, job, gender; private int salary, age; //setter和getter还有构造器自己写,当然可以生成&#125; 我们先填充一些数据吧: 123456789101112131415161718192021222324252627282930List&lt;Person&gt; javaProgrammers = new ArrayList&lt;Person&gt;() &#123; &#123; add(new Person(&quot;Elsdon&quot;, &quot;Jaycob&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 43, 2000)); add(new Person(&quot;Tamsen&quot;, &quot;Brittany&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 23, 1500)); add(new Person(&quot;Floyd&quot;, &quot;Donny&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 33, 1800)); add(new Person(&quot;Sindy&quot;, &quot;Jonie&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 32, 1600)); add(new Person(&quot;Vere&quot;, &quot;Hervey&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 22, 1200)); add(new Person(&quot;Maude&quot;, &quot;Jaimie&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 27, 1900)); add(new Person(&quot;Shawn&quot;, &quot;Randall&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 30, 2300)); add(new Person(&quot;Jayden&quot;, &quot;Corrina&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 35, 1700)); add(new Person(&quot;Palmer&quot;, &quot;Dene&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 33, 2000)); add(new Person(&quot;Addison&quot;, &quot;Pam&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 34, 1300)); &#125; &#125;; List&lt;Person&gt; phpProgrammers = new ArrayList&lt;Person&gt;() &#123; &#123; add(new Person(&quot;Jarrod&quot;, &quot;Pace&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 34, 1550)); add(new Person(&quot;Clarette&quot;, &quot;Cicely&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 23, 1200)); add(new Person(&quot;Victor&quot;, &quot;Channing&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 32, 1600)); add(new Person(&quot;Tori&quot;, &quot;Sheryl&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 21, 1000)); add(new Person(&quot;Osborne&quot;, &quot;Shad&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 32, 1100)); add(new Person(&quot;Rosalind&quot;, &quot;Layla&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 25, 1300)); add(new Person(&quot;Fraser&quot;, &quot;Hewie&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 36, 1100)); add(new Person(&quot;Quinn&quot;, &quot;Tamara&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 21, 1000)); add(new Person(&quot;Alvin&quot;, &quot;Lance&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 38, 1600)); add(new Person(&quot;Evonne&quot;, &quot;Shari&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 40, 1800)); &#125; &#125;; 先来筛选下工资大于1400的PHP程序员: 12phpProgrammers.stream().filter(person -&gt; person.getSalary()&gt;1400) .forEach(e-&gt; System.out.printf("%s %s %s;",e.getFirstName(),e.getLastName(),e.getSalary())); 看这个这个写法是不是感觉有像数据库操作,无论是之前的sort还是这个filter本质都是返回一个流Stream对象,]]></content>
      <tags>
        <tag>JDK1.8,新特性,Lambda,stream流编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一起学习JDK1.8新特性(三)]]></title>
    <url>%2Funcategorized%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[上次和朋友一起去网吧通宵,因为当时穿着那种很长的睡衣,被很多人盯着,于是我们干脆全带着墨镜玩了一晚上的电脑,白天走的时候悄无声息,事后老板点起烟悠悠说出一个阴兵过网吧的故事 上回说到JDK1.8的重中之重,今天我们就来练习下这个新特性 1234567891011121314151617181920@FunctionalInterface//指定唯一函数接口:并不是这个接口只能有一个方法,里面还可以有默认方法interface Interface2&#123; int sum(int a,int b); //默认方法是可以有方法体的,这个是jdk1.8的新特性,接口可以有具体方法(default) default int reduce(int a,int b,int c)&#123; return this.sum(a,b)-c;//可以访问this &#125;&#125;public class ExpTest7 &#123; public static void main(String[] args)&#123; Interface2 interface2 = (a,b)-&gt;a+b;//对于lambda表达式来说默认实现的方法只有一个,那就是上面的sum() int sum = interface2.sum(8, 9); System.out.println(sum); int reduce = interface2.reduce(6,8, 2); System.out.println(reduce); &#125;&#125; 这里我们以Consumer这个类的规格去写这个例子,写好测试下,代码可以运行,没毛病!!Interface2虽然有两个方法,可是我们只能用那么没有方法体的方法去得到这个接口的实例,为什么呢??具体非静态方法是需要实例去运行的,常规操作当然不能反向获取啦 这里可以在代码运行后试下,在Interface2里面加方法,就会发现会报错,报错内容首先是这个注解,说是这个接口里面没有重写的方法,因为我们在测试里面实例化了一个接口对象,但是实例化的只用了一个方法,所以这里应该这样去理解,你的接口有两个方法,实例化对象的时候重写了一个,还有一个没重写,相当于你写一个类去实现有两个方法的接口,但是你只实现了一个方法,且类又不是抽象类,这就很尴尬了,不上不下 到这里,可能会有人说这个接口的注解(@FunctionalInterface)作祟,没事,我们把这个接口的注解注释掉,会发现还是报错,这次报错实在你的Lambda表达式里面,直接说你的表达式操作符有问题,这个就没话讲了,事实证明,使用Lambda表达式的接口可以有defaul方法(有方法体) 不信我们来看下关于@FunctionalInterface的源码怎么说的 12345678910111213141516171819202122232425262728293031323334353637383940414243package java.lang;import java.lang.annotation.*;/** * An informative annotation type used to indicate that an interface * type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as * defined by the Java Language Specification. * * Conceptually, a functional interface has exactly one abstract * method. Since &#123;@linkplain java.lang.reflect.Method#isDefault() * default methods&#125; have an implementation, they are not abstract. If * an interface declares an abstract method overriding one of the * public methods of &#123;@code java.lang.Object&#125;, that also does * &lt;em&gt;not&lt;/em&gt; count toward the interface&apos;s abstract method count * since any implementation of the interface will have an * implementation from &#123;@code java.lang.Object&#125; or elsewhere. * * &lt;p&gt;Note that instances of functional interfaces can be created with * lambda expressions, method references, or constructor references. * * &lt;p&gt;If a type is annotated with this annotation type, compilers are * required to generate an error message unless: * * &lt;ul&gt; * &lt;li&gt; The type is an interface type and not an annotation type, enum, or class. * &lt;li&gt; The annotated type satisfies the requirements of a functional interface. * &lt;/ul&gt; * * &lt;p&gt;However, the compiler will treat any interface meeting the * definition of a functional interface as a functional interface * regardless of whether or not a &#123;@code FunctionalInterface&#125; * annotation is present on the interface declaration. * * @jls 4.3.2. The Class Object * @jls 9.8 Functional Interfaces * @jls 9.4.3 Interface Method Body * @since 1.8 */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface FunctionalInterface &#123;&#125; 官方是这样声明的,这个注解通常被用来修饰一个函数接口去定义一个java的语法,硬性规定一个函数接口只能有一个抽象方法,同时可以有实现的方法(这个方法在java.lang.reflect.Method的isDefault()方法下识别),它(default方法)不是抽象方法,若是一个接口的方法被具体实现了那么将不能作为一个函数接口,大概说的就是这些(题主英文薄弱,只能按自己的理解翻译成这样子,见谅见谅) 官方说的很明白了,这玩意一般用在Lambda表达式方法体或者构造器里面,我们使用的例子无非如此,若是有不太明白的人可以把上面的注释用百度或者有道翻译去翻译成中文看下,大概说的是不是和题主自己理解的一致(题主的翻译仅供参考,毕竟是自己翻译的,不是专业的) 再来说下关于这个default方法声明,我们看个例子 1234567891011121314151617181920@FunctionalInterface//指定唯一函数接口:并不是这个接口只能有一个方法,里面还可以有默认方法interface Interface2&#123; int sum(int a,int b); default int reduce(int a,int b,int c)&#123;//默认方法是可以有方法体的,这个是jdk1.8的新特性,接口可以有具体方法(default) return this.sum(a,b)-c;//可以访问this &#125;&#125;@FunctionalInterface//指定唯一函数接口:并不是这个接口只能有一个方法,里面还可以有默认方法interface Interface3&#123; int sum(int a,int b,int c); default int reduce(int a,int b,int c)&#123;//默认方法是可以有方法体的,这个是jdk1.8的新特性,接口可以有具体方法(default) return sum(a,b,c)-c; &#125;&#125;interface iterface4 extends Interface2,Interface3&#123; @Override default int reduce(int a, int b, int c) &#123;//使用默认方法要指定对应的接口 return Interface3.super.reduce(a,b,c); &#125;&#125; 我们定义一个接口去实现这个两个函数接口的时候重写他的default方法的时候,若是这两个default方法名相同,必须要声明对应的那个接口(我们例子里面也是在两个default方法名字是相同的前提下) 是不是我们用Lambda表达式一定要自己定义接口的,并不是这样的,如果这样的话我们还需要大量的定义接口,且接口的数量是根据方法的数量去定制的,这样会很大的增加我们的工作量,幸好这些都不用担心,JDK1.8为我们提供很多好用的接口,这些接口在java.util.function包下,我们以后的教程会大量的用到这个包里面的接口 我们先写一个小例子 12345678910111213141516171819202122232425interface IMoney&#123;//这个接口可以省略,JDK1.8为我们提供了一个函数接口Function&lt;T,R&gt;用他去实现就好了 String format(int money);&#125;class MyMoney&#123;//当前这个类调用了接口的方法,可没有具体实现,在测试代码去做实现 private final int money; public MyMoney(int money)&#123; this.money=money; &#125; public void printfMoney(IMoney iMoney)&#123;//传入接口进去,让接口去具体实现 System.out.println("我的存款:"+iMoney.format(money)+"元"); &#125;&#125;//测试类public class ExpTest &#123; public static void main(String[] args)&#123; MyMoney my = new MyMoney(7800568); my.printfMoney(imoney-&gt;new DecimalFormat("#,###").format(imoney)); &#125;&#125; 在上面的例子中我们先是定义了一个接口里面有个format方法,然后下面的类有个方法传入的是上面的接口对象,调用就直接打印一句话在控制台,我们用Lambda表达式的特性—返回对应函数的接口实例,这里我们用了一个DecimalFormat对象的format方法,传入的是一个long类型的参数,这里默认做了类型的自动提升,返回的也正好是一个String,符合我们IMoney的format方法(Lambda表达式只注重输入和输出) 下面先简单的使用一下,让我们释放自己的接口,试着用官方的接口去写Lambda表达式 1234567891011121314151617181920class MyMoney&#123;//当前这个类调用了接口的方法,可没有具体实现,在测试代码去做实现 private final int money; public MyMoney(int money)&#123; this.money=money; &#125; public void printfMoney(Function&lt;Integer,String&gt; function)&#123;//传入接口进去,让接口去具体实现 System.out.println("我的存款:"+function.apply(money)+"元"); &#125;&#125;public class ExpTest8 &#123; public static void main(String[] args)&#123; MyMoney my = new MyMoney(7800568); //使用函数接口的好处:1,不用定义太多的接口 Function&lt;Integer,String&gt; function = money -&gt; new DecimalFormat("#,###").format(money);//这里就是具体的调用 //2.函数的链式操作 my.printfMoney(function.andThen(s-&gt;"软妹币:"+s)); &#125;&#125; 在第二种方法的例子中我们并没有使用到这个定义的接口,但同样实现了效果,这里我们先从”money -&gt; new DecimalFormat(“#,###”).format(money)”入手,这个Lambda表达式返回的是一个Function&lt;T,R&gt;这里跟下源码给大家看看这个Function这个接口到底是个啥 123456789101112131415161718192021/** * Represents a function that accepts one argument and produces a result. * * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt; * whose functional method is &#123;@link #apply(Object)&#125;. * * @param &lt;T&gt; the type of the input to the function * @param &lt;R&gt; the type of the result of the function * * @since 1.8 */@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); 他说这个接口函数只支持一个入参一个输出,也是就&lt;T,R&gt;前面的是入参,后面的是输出,调用apply输入T返回一个R(T和R都是泛型),在这里又一次的展示了java面向对象的特性,我们只需要有一个接口,里面有个方法,一个输入,一个输出即可,而这二者Function&lt;T,R&gt;都符合,自然成为了首选 我们用方法二实现了不用自己定义的接口也能格式化我们想要的内容,为什么要用这个Function呢?很简单,可以支持链式调用又可以少定义接口,何乐而不为,所谓了链式操作即是指:不立即返回结果,而是在缓存中继续对其进行加工操作,我的例子就是给这个钱的数字格式化,前面加了’软妹币’,但又没有破坏代码的整体性 注意这个我们学习了一个新的官方函数接口Function&lt;T,R&gt;,意思是我们只需要知道一个方法的调用入参和返回结果都是一个,那么使用它能让你节省很多时间,并且他是泛型的入参和输出,意味着我们只要有满足一个输出一个输出的需求,那么就是可以使用它作为返回值 不知道大家注意到没有,这个Function和上面提到的Consumer都是java.util.function包下面的接口,都是有@FunctionalInterface的注解修饰的,但他们的用处不同,我们以后会接触到更多类似这样的接口的,到这我们的Lambda就先告一段落,但内容远不止我所讲的这么多,我只是把一些简单易懂的挑出来给大家看看,毕竟要学还多还狠多,在接下来的教程我将为大家带来JDK1.8的另一个新的特性]]></content>
      <tags>
        <tag>jdk1.8,新特性,Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一起学习JDK1.8新特性(二)]]></title>
    <url>%2Funcategorized%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[那一天,我又再次看到了她,还是在同一个地方,那天阳光正好,她一如往常一样,一身洁白的连衣裙,如同童话里的公主,连 动作都是一样,哇…挖鼻孔挖的这么起劲 上次我们初步介绍了JDK1.8的新特性,介绍了基本的Lambda表达式的写法,和部分用法,今天,我们接续学习这个新特性,先来看下例子 12345678910111213String[] atp = &#123;"Rafael Nadal", "Novak Djokovic","Stanislas Wawrinka", "David Ferrer","Roger Federer","Andy Murray","Tomas Berdych", "Juan Martin Del Potro"&#125;;List&lt;String&gt; list = Arrays.asList(atp);//常规操作for(String str:list)&#123; System.out.println(str+";");&#125;//lambda一般写法:里面是个消费者Consumer&lt;?&gt;(lambda表达式的实质就是这个,这个现在不深入以后再讲)list.forEach(str-&gt; System.out.println(str+";")); 通过上面的例子我们知道了常规循环和新特性的循环有那些区别,常规的是for循环写法,而在JDK1.8中List接口里面新增了forEach()方法直接遍历,回到最原始的话题,我为什么要写关于JDK1.8的博客就是这个原因,在1.8前List这个接口一直没动过,现在好了,加了新东西,自然要去学习他 扯远了,让我们看下高级操作 12//高级操作list.forEach(System.out::println); 同样是循环,为什么各个方法之间的代码量会差这么多,这就是Lambda的函数式编程魅力,以前我们在写代码的时候总是在想着怎么去实现它,现在好了,不需要关注过程,只需要关注结果,就像我上一篇的文章一样,定义一个函数,但是我们并没有专门写一个类去怎么实现,相反,我们使用Lambda表达式直接去对其运用,这就是函数式编程,只侧重输入输出,不侧重过程,可以预见我们未来的编程会越来越模块化,越智能化,但这对于一个新手来说是致命了,因为你不了解他的原理,只是会照本宣科而已,这样下去思想会越来越迟钝,因此我们要知其然知其所以然 这里再来练习下Lambda的函数式编程的例子 我们写个一般的排序代码如下： 12345678910111213String[] atp = &#123;"Rafael Nadal", "Novak Djokovic","Stanislas Wawrinka", "David Ferrer","Roger Federer","Andy Murray","Tomas Berdych", "Juan Martin Del Potro"&#125;;//List&lt;String&gt; list = Arrays.asList(atp);//常规操作Arrays.sort(atp, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o1.compareTo(o2); &#125;&#125;); 再来写个Lambda表达式的实现 123//lambda表达式:将重写的方法简化Comparator&lt;String&gt; comparator = (String str1,String str2)-&gt;str1.compareTo(str2);Arrays.sort(atp,comparator); 我们这里看到的这个其实很好理解,用Lambda得到一个Comparator接口的对象,就像我们自己定义的接口一样,输入两个参数,输出的是这个接口的方法的调用,这样就会这个接口的对象实例 比较代码,其实真没什么区别,别急看下面的就会发现区别在哪里了 12//orArrays.sort(atp,(String str1,String str2)-&gt;str1.compareTo(str2)); 这里我们第二个参数直接省略new这个接口的过程,对比这个写法和第一个普通写法,我们就已经知道了Lambda表达式的用法,总之,多去练习,加深印象 如果你用的开发工具是IDEA,那么恭喜你,你可以看到函数式编程的核心提示—Override,把鼠标放在代码行的坐标(打断点的地方),这里如果是Lambda表达式,那么你会看到有个”λ”的样子的符号,放上去你会发现有说明这个方法是Overrrides method in java.util.function.Consumer这个类的提示,这就是本质override 让我们进去源码去看下这个Consumer类的说明 1234567891011121314/** * Represents an operation that accepts a single input argument and returns no * result. Unlike most other functional interfaces, &#123;@code Consumer&#125; is expected * to operate via side-effects. * * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt; * whose functional method is &#123;@link #accept(Object)&#125;. * * @param &lt;T&gt; the type of the input to the operation * * @since 1.8 */@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; 可以看到这个是一个可以接收一个参数没有返回值,这玩意不像其他函数接口一样这个是操作边缘化的东西,自己手动翻译的,很不准确,但不难看出,这接口很类似我们在我上一篇文章写得那个例子,只不过多了一个@FunctionalInterface的注解,先不管这个接口用来干嘛的,我们看下他的方法,有两个,分别是accept和andThen 123456789101112131415161718192021222324/** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); /** * Returns a composed &#123;@code Consumer&#125; that performs, in sequence, this * operation followed by the &#123;@code after&#125; operation. If performing either * operation throws an exception, it is relayed to the caller of the * composed operation. If performing this operation throws an exception, * the &#123;@code after&#125; operation will not be performed. * * @param after the operation to perform after this operation * @return a composed &#123;@code Consumer&#125; that performs in sequence this * operation followed by the &#123;@code after&#125; operation * @throws NullPointerException if &#123;@code after&#125; is null */ default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125;&#125; 这里我们注意下这个andThen方法,众所周知,不管在1.6还是1.7接口里面都是不能有具体实现的方法的,以此类推,那么1.8一个极其重要的特性就出来了,接口里面可以存在一个具体的方法,这个方法有具体的方法体,但是要以default关键字开头,我个人认为这个特性非常重要,是1.8的重中之重 到这里,解析源码先告一段落,来动下手练习下刚才所学的,今天讲的有点多,各位需要多加练习,加深印象和巩固知识,还是那句话,知其然,知其所以然]]></content>
      <tags>
        <tag>jdk1.8,新特性,Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一起学习JDK1.8新特性(一)]]></title>
    <url>%2Funcategorized%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[每次相遇,都是久别重逢,很多时候我们看到的仅仅只是看到的,但是,当你接触她后,就会发现,并没什么卵用… 今天,我们正式接触JDK1.8,让我们来接触下这个船新版本(是兄弟,就来砍我!!!),跑偏了,言归正传,JDK作为一个java开发者,无论是web还是其他开发,我们都会去选择对应的版本,今天就让我们开始进入1.8的新特性 首先,来介绍个最简单的例子 我们在编程中,在jdk1.8前一般会这样去获取数组中的最小值 123456789//正常的选择最小值int[] arr = &#123;12,78,58,36,-25,-56,89,0&#125;;int min = Integer.MAX_VALUE;for (int i = 0; i &lt;arr.length ; i++) &#123; if(arr[i]&lt;min)&#123; min=arr[i]; &#125;&#125;System.out.println("最小值为:" + min); 但是,当我们学习JDK1.8后就会发现,这样子就有点繁琐,话不多说,上代码 12int[] arr = &#123;12,78,58,36,-25,-56,89,0&#125;;System.out.println("最小值为:" + IntStream.of(arr).min().getAsInt()); 惊不惊喜,意不意外!JDK1.8相对之前的版本来说,可以说是修改了相当多的东西,有很多新特性和接口方法需要我们去一一实验 刚接触语言,首先要了解他的语法,这里声明下,此教程,仅适用于有基础的开发同学,若是基础薄弱,请移步w3c学习基础,或者其他渠道学习 在JDK1.8中新增的语法就是Lambda表达式,我们先来看个例子,来看下什么是lambda表达式 在此之前,先回顾下线程的调用知识 123456789//在这里我们创建一个Runable对象,重写他的run方法Runnable target = new Runnable() &#123; @Override public void run() &#123; System.out.println("I'm OK"); &#125;&#125;;//这里就是调用的步骤了new Thread(target).start(); 在JDK1.8中我们可以这样去声明这个接口 1234//Lambda表达式的写法就是这样()-&gt;?Runnable target1 = ()-&gt; System.out.println("I'm OK");//调用没区别new Thread(target1).start(); 综上所述,我们粗略的了解了一下,所谓的Lambda表达式就是形如:”()-&gt;输出”这样的表达式就是Lambda表达式,再对比这个接口的run方法,其实不难看出这里他简化了这个接口的实现,我们可以不必定义一个Runnable接口去写他的run方法,而是用”()-&gt;”的方式去代替重写的部分 依次类推,我们可以自己定义一个接口去做相应的实现 1234567891011121314interface Interface&#123; String print();&#125;public class ExpTest3 &#123; public static void main(String[] args)&#123; //Lambda表达式书写 Interface i = ()-&gt; "Extreme大佬"; System.out.println(i.print()); &#125;&#125; 其实到这里我们就知道了什么是Lambda表达式,以及他的用处:简化接口的和代码的实现 怎么样,是不是很好理解?大家有空要多练习写这个写法,就能更深入的理解了 下面就来看看有几种写法吧 1234567891011121314151617181920212223interface Interface1&#123; int doubleNum(int i);&#125;public class ExpTest3 &#123; public static void main(String[] args)&#123; Interface1 i1 = (i) -&gt; i*2; Interface1 i4 = (int i) -&gt; i*2; //最常见的写法(推荐) Interface1 i2 = i -&gt; i*3; Interface1 i3 = (int i) -&gt; &#123; System.out.println(i + "----"); return i*4; &#125;; &#125;&#125; 四种写法看起来大同小异,但我们推荐i2的写法,因为jdk1.8会为我们自行做类型推断,所以可以不用定义输入类型也能运行 好了,今天先整理到这里,Lambda表达式本质就是接口的实现,其实就是让我们操作接口变得更加容易,简单,便捷,少写代码,但这里我要着重说下输出参数的时候取名字一定,务必,肯定,确定要取好,和对应的接口实现有关的名字,本来类型就没有要是你的变量名都不清楚,那就很无语了….]]></content>
      <tags>
        <tag>jdk1.8,新特性,Lambda</tag>
      </tags>
  </entry>
</search>
