<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一起学习JDK1.8新特性(一)]]></title>
    <url>%2Funcategorized%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[每次相遇,都是久别重逢,很多时候我们看到的仅仅只是看到的,但是,当你接触她后,就会发现,并没什么卵用… 今天,我们正式接触JDK1.8,让我们来接触下这个船新版本(是兄弟,就来砍我!!!),跑偏了,言归正传,JDK作为一个java开发者,无论是web还是其他开发,我们都会去选择对应的版本,今天就让我们开始进入1.8的新特性 首先,来介绍个最简单的例子 我们在编程中,在jdk1.8前一般会这样去获取数组中的最小值 123456789//正常的选择最小值int[] arr = &#123;12,78,58,36,-25,-56,89,0&#125;;int min = Integer.MAX_VALUE;for (int i = 0; i &lt;arr.length ; i++) &#123; if(arr[i]&lt;min)&#123; min=arr[i]; &#125;&#125;System.out.println("最小值为:" + min); 但是,当我们学习JDK1.8后就会发现,这样子就有点繁琐,话不多说,上代码 12int[] arr = &#123;12,78,58,36,-25,-56,89,0&#125;;System.out.println("最小值为:" + IntStream.of(arr).min().getAsInt()); 惊不惊喜,意不意外!JDK1.8相对之前的版本来说,可以说是修改了相当多的东西,有很多新特性和接口方法需要我们去一一实验 刚接触语言,首先要了解他的语法,这里声明下,此教程,仅适用于有基础的开发同学,若是基础薄弱,请移步w3c学习基础,或者其他渠道学习 在JDK1.8中新增的语法就是Lambda表达式,我们先来看个例子,来看下什么是lambda表达式 在此之前,先回顾下线程的调用知识 123456789//在这里我们创建一个Runable对象,重写他的run方法Runnable target = new Runnable() &#123; @Override public void run() &#123; System.out.println("I'm OK"); &#125;&#125;;//这里就是调用的步骤了new Thread(target).start(); 在JDK1.8中我们可以这样去声明这个接口 1234//Lambda表达式的写法就是这样()-&gt;?Runnable target1 = ()-&gt; System.out.println("I'm OK");//调用没区别new Thread(target1).start(); 综上所述,我们粗略的了解了一下,所谓的Lambda表达式就是形如:”()-&gt;输出”这样的表达式就是Lambda表达式,再对比这个接口的run方法,其实不难看出这里他简化了这个接口的实现,我们可以不必定义一个Runnable接口去写他的run方法,而是用”()-&gt;”的方式去代替重写的部分 依次类推,我们可以自己定义一个接口去做相应的实现 1234567891011121314interface Interface&#123; String print();&#125;public class ExpTest3 &#123; public static void main(String[] args)&#123; //Lambda表达式书写 Interface i = ()-&gt; "Extreme大佬"; System.out.println(i.print()); &#125;&#125; 其实到这里我们就知道了什么是Lambda表达式,以及他的用处:简化接口的和代码的实现 怎么样,是不是很好理解?大家有空要多练习写这个写法,就能更深入的理解了 下面就来看看有几种写法吧 1234567891011121314151617181920212223interface Interface1&#123; int doubleNum(int i);&#125;public class ExpTest3 &#123; public static void main(String[] args)&#123; Interface1 i1 = (i) -&gt; i*2; Interface1 i4 = (int i) -&gt; i*2; //最常见的写法(推荐) Interface1 i2 = i -&gt; i*3; Interface1 i3 = (int i) -&gt; &#123; System.out.println(i + "----"); return i*4; &#125;; &#125;&#125; 四种写法看起来大同小异,但我们推荐i2的写法,因为jdk1.8会为我们自行做类型推断,所以可以不用定义输入类型也能运行 好了,今天先整理到这里,Lambda表达式本质就是接口的实现,其实就是让我们操作接口变得更加容易,简单,便捷,少写代码,但这里我要着重说下输出参数的时候取名字一定,务必,肯定,确定要取好,和对应的接口实现有关的名字,本来类型就没有要是你的变量名都不清楚,那就很无语了….]]></content>
      <tags>
        <tag>jdk1.8,新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
